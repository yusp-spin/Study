---
title: RocketMQ版的分布式事务实现
date: 2021-09-25 16:40:23
categories: MQ
tags: 分布式事务
---

##### 一、 什么是RocketMQ

RocketMQ 是阿里巴巴开源的分布式消息中间件。支持消息重试、延时消息、消息追踪、实时消息、分布式事务消息等。它里面有几个区别于标准消息中件间的概念，如Group、Topic、Queue等。系统组成则由Producer、Consumer、Broker、NameServer等。

##### 二、RocketMQ 特点

- 是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式等特点
- Producer、Consumer、队列都可以分布式
- Producer 向一些队列轮流发送消息，队列集合称为 Topic，Consumer 如果做广播消费，则一个 Consumer 实例消费这个 Topic 对应的所有队列，如果做集群消费，则多个 Consumer 实例平均消费这个 Topic 对应的队列集合
- 能够保证严格的消息顺序
- 支持拉（pull）和推（push）两种消息模式
- 高效的订阅者水平扩展能力
- 实时的消息订阅机制
- 亿级消息堆积能力
- 支持多种消息协议，如 JMS、OpenMessaging 等
- 较少的依赖

##### 三、分布式场景

假设 **A** 给 **B** 转 **100块钱**，同时它们不是同一个服务上。

##### `目标`：就是 **A** 减100块钱，**B** 加100块钱。

实际情况可能有四种：

```
1）就是A账户减100 （成功），B账户加100 （成功）

2）就是A账户减100（失败），B账户加100 （失败）

3）就是A账户减100（成功），B账户加100 （失败）

4）就是A账户减100 （失败），B账户加100 （成功）
```

这里 **第1和第2** 种情况是能够保证事务的一致性的，但是 **第3和第4** 是无法保证事务的一致性的。

那我们来看下RocketMQ是如何来保证事务的一致性的

##### 四、RocketMQ分布式事务原理

<div>
    <p style="text-align:center">
    <img src="https://yusp-spin.github.io/photo/rocketMq.jpg" width=700 height=300 />
    <br>rocketMq分布式
    </p>
</div>


1、A服务先发送个Half Message给Brock端，消息中携带 B服务 即将要+100元的信息。 2、当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。 3、执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应) 4.1)、如果本地事务成功，那么Product像Brock服务器发送Commit,这样B服务就可以消费该message。 4.2)、如果本地事务失败，那么Product像Brock服务器发送Rollback,那么就会直接删除上面这条半消息。 4.3)、如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口,来进行事务的回查。

从上面流程可以得知 `只有A服务本地事务执行成功 ，B服务才能消费该message`。

然后我们再来思考几个问题？

```
为什么要先发送Half Message(半消息)
```

我觉得主要有两点

```
1）可以先确认 Brock服务器是否正常 ，如果半消息都发送失败了 那说明Brock挂了。

2）可以通过半消息来回查事务，如果半消息发送成功后一直没有被二次确认，那么就会回查事务状态。
什么情况会回查
```

也会有两种情况

```
1）执行本地事务的时候，由于突然网络等原因一直没有返回执行事务的结果(commit或者rollback)导致最终返回UNKNOW，那么就会回查。

2) 本地事务执行成功后，返回Commit进行消息二次确认的时候的服务挂了，在重启服务那么这个时候在brock端
   它还是个Half Message(半消息)，这也会回查。
```

**特别注意**: 如果回查，那么**一定要先查看当前事务的执行情况，再看是否需要重新执行本地事务。**

想象下如果出现第二种情况而引起的回查，如果不先查看当前事务的执行情况，而是直接执行事务，那么就相当于成功执行了两个本地事务。

```
为什么说MQ是最终一致性事务
```

通过上面这幅图，我们可以看出，在上面举例事务不一致的两种情况中，永远不会发生

```
A账户减100 （失败），B账户加100 （成功）
```

**因为**：如果A服务本地事务都失败了，那B服务永远不会执行任何操作，因为消息压根就不会传到B服务。

那么 **A账户减100 （成功），B账户加100 （失败）** 会不会可能存在的。

**答案是会的**

因为A服务只负责当我消息执行成功了，保证消息能够送达到B,至于B服务接到消息后最终执行结果A并不管。

**那B服务失败怎么办？**

如果B最终执行失败，几乎可以断定就是代码有问题所以才引起的异常，因为消费端RocketMQ有重试机制，如果不是代码问题一般重试几次就能成功。

如果是代码的原因引起多次重试失败后，也没有关系，将该异常记录下来，由`人工处理`，人工兜底处理后，就可以让事务达到最终的一致性。



参考资料：

https://www.cnblogs.com/weifeng1463/p/12889300.html

https://www.jianshu.com/p/3afd610a8f7d