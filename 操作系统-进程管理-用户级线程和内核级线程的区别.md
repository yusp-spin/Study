---
title: 操作系统-进程管理-用户级线程和内核级线程的区别
date: 2020-10-31 17:07:23
categories: 操作系统
tags: 线程
---
##### 一、线程的分类

​	线程的实现可以分为两大类：**用户级线程**和**内核级线程**。

###### 1.用户级线程

​	在一个纯粹的用户级线程软件中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。任何应用程序都可以通过使用线程库被设计成多线程程序。线程库是用于用户级线程管理的一个例程包，它包含用于创建和销毁线程的代码、在线程间传递消息和数据的代码、调度线程执行的代码、以及保存和恢复线程上下文的代码。在默认情况下，应用程序从单线程开始，并在该线程中开始运行。该应用程序及其线程被分配给一个由内核管理的进程。在应用程序正在运行（进程处于运行态）的任何时刻，应用程序都可以派生一个在相同进程中运行的新线程（派生线程是通过调用线程库中的派生例程完成的，通过过程调用，控制权被传递给派生例程）。线程库为新线程创建一个数据结构，然后使用某种调度算法，把控制权传递给该进程中处于就绪态的一个线程。当控制权被传递给线程库时，需要保存当前线程的上下文，然后当控制权从线程库中传递给一个线程时，将恢复哪个线程的上下文。上下文实际上包括用户寄存器的内容、程序计数器和栈指针

在前一段描述的所有活动都发生在用户空间中，并且发生在一个进程内，而内核并不知道这些活动。内核继续以进程为单位进行调度，并且给该进程指定一个执行状态。

使用用户级线程而不是内核线程有很多优点：

> **1、由于所有线程管理数据结构都在一个进程的用户地址空间中，线程切换不需要内核态特权；**
>
> **2、调度可以是应用程序相关的，可以做到为应用程序量身定做调度算法而不扰乱底层的操作系统调度程序；**
>
> **3、用户级线程可以在任何操作系统中运行，线程库是一组供所有应用程序共享的应用程序级别的函数。**

使用用户级线程而不是内核线程有两个明显的缺点：

> **1、当用户级线程执行一个会引起阻塞的系统调用时，不仅这个线程会被阻塞，进程中的所有线程都会被阻塞；**
>
> **2、在纯粹的用户级线程策略中，多线程应用程序不能利用多处理技术，内核一次只把一个进程分配给一个处理器，因此一次进程中只有一个线程可以执行。**



###### 2.内核级线程

在一个纯粹的内核级线程软件中，有关线程管理的所有工作都是由内核完成的，应用程序部分没有进行线程管理的代码，只有一个到内核线程设施的应用程序编程接口（API）。Windows 是这种方法的一个例子。

内核为进程及其内部的每个线程维护上下文信息。调度是由内核基于线程完成的。该方法克服了用户级线程方法的两个基本缺陷（优点：）：

> **首先：内核可以同时把同一个进程中的多个线程调度到多个处理器中；**
>
> **再者：如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程；**
>
> **另外：内核例程自身也是可以使用多线程的。**

缺点：把控制从一个线程传送到同一个进程内的另一个线程时，需要到内核的状态转换



##### 二、Windows线程

​	Windows 使用两类与进程相关的对象：进程和线程。

​	进程是对应一个拥有内存、打开的文件等资源的用户作业或应用程序的实体。线程是顺序执行的一个科分派的工作单元，并且它是可中断的，因此，处理器可以切换到另一个线程。一个 Windows 进程必须至少包含一个执行线程，该线程可能会创建别的线程。在多处理器系统中，同一个进程的多个线程可以并行的执行。

​	由于不同进程中的线程可能并非执行，因而 Windows 支持进程间的并发性。此外，同一个进程中的多个线程可以分配给不同的处理器并且同时执行。一个含有多线程的进程在实现并发时，不需要使用多进程的开销。同一个进程中的线程可以通过他们的公共地址空间交换信息，并访问进程中的共享资源，不同进程中的线程可以通过在两个进程间建立的共享内存交换信息



##### 三、Linux的进程和线程管理

​	Linux 中的进程或任务由一个 task_struct 数据结构表示。

​	传统的 UNIX 系统支持每个执行的进程中只有一个单独的一个线程，但现代典型的 UNIX 系统支持一个进程中含有多个 内核级线程。

**	Linux 提供一种不区分进程和线程的解决方案**。用户级线程被映射到内核级进程上，组成一个用户级进程的多个用户级线程被映射到共享同一个组 ID 的多个 Linux 内核级进程上。这使得这些进程可以共享文件和内存等资源，使得同一组中的进程调度切换时不需要切换上下文。

​	当两个进程共享相同的虚存时，它们可以被当做是一个进程中的线程。

​	当 Linux 内核执行从一个进程到另一个进程的切换时，它将坚持当前进程的页目录地址是否和将被调度的进程相同。如果相同，那么它们共享同一个地址空间，所以此时上下文切换仅仅是从代码的一处跳转到代码的另一处。

​	虽然属于同一进程组的被克隆的进程共享同一内存空间，但它们不能共享同一个用户栈。



##### 四、总结

​	用户级线程对操作系统是未知的，它们由一个在进程的用户空间中运行的线程库创建并管理。用户线程是非常高效的，因为从一个线程切换到另一个线程不需要进行状态切换，但是，一个进程中一次只有一个用户级线程可以执行，如果一个线程发生阻塞，整个进程都会被阻塞。

​	进程内包含的内核级线程是由内核维护的。由于内核认识它们，因而同一个进程中的多个线程可以再多个处理器上并行执行，一个线程的阻塞不会阻塞整个进程，但当从一个线程切换到另一个线程时就会需要进行模式切换。